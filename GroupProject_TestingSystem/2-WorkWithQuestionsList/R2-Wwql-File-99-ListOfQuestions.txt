|1|Циклы|Что такое циклы?|Команды для изменения порядка выполнения инструкций|Структуры, позволяющие многократно выполнять набор инструкций|Функции для преобразования типов данных|Методы для создания массивов|Структуры, позволяющие многократно выполнять набор инструкций|2|
|2|Циклы|Сколько видов циклов существует?|1|2|3|4|3|3|
|3|Циклы|Для чего нужен оператор break?|Для полного выхода из цикла|Для пропуска одной итерации цикла|Для завершение работы программы|Для перехода на другой цикл|Для полного выхода из цикла|1|
|4|Циклы|Для чего нужен оператор continue?|Для пропуска одной итерации и выхода из цикла|Для продолжения работы цикла|Для выхода из цикла|Для пропуска одной итерации без выхода из цикла|Для пропуска одной итерации без выхода из цикла|4|
|5|Циклы|Цикл в C состоит из двух частей: _____ цикла и управляющего _____ .|итерации, оператора|тела, оператора|тела, значения|оператора, тела|тела, оператора|2|
|6|Циклы|Что выведет следующий код: for(int num = 1; num <= 10; num++) printf(" %d \n", num);|Выведет числа от 10 до 1|Выведет числа от 0 до 10|Выведет числа от 1 до 10|Ничего|Выведет числа от 1 до 10|3|
|7|Циклы|Особенность цикла do while|Выполниться хотя бы один раз|Не имеет операторов|Выход из цикла осуществляется оператором continue|Нет условия продолжения цикла|Выполниться хотя бы один раз|1|
|8|Циклы|Что произойдет, если в условии цикла for не указать ни одного выражения?|Цикл не будет выполнен|Произойдет ошибка компиляции|Будет создан бесконечный цикл|Цикл выполнится один раз|Будет создан бесконечный цикл|3|
|9|Циклы|Какой из следующих вариантов корректно инициализирует цикл while?|while x = 0|while (x = 0)|while x == 0|while (x == 0)|while (x == 0)|4|
|10|Циклы|Какое выражение в цикле for определяет условие продолжения цикла?|Инициализация|Условие|Итерация|Тело цикла|Условие|2|
|11|Массивы|Какой индекс у последнего элемента массива char Arr[25]?|24|25|26|0|24|1|
|12|Массивы|Какой синтаксис используется для объявления массива Arr из 10 элементов типа float?|float Arr|float Arr[10]|Arr = {float[10]}|Create_array float Arr[10]|float Arr[10]|2|
|13|Массивы|Какое значение будет в Arr[3] после выполнения следующего кода: int Arr[5] = {1, 2, 3} ?|0|3|4|Неопределенное значение|0|1|
|14|Массивы|Как правильно инициализировать массив Arr тремя элементами со значениями 5, 10, 15?|int Arr(3) = {5, 10, 15}|int Arr[3]; Arr = {5, 10, 15}|int Arr = {5, 10, 15}|int Arr[3] = {5, 10, 15}|int Arr[3] = {5, 10, 15}|4|
|15|Массивы|Какой из следующих вариантов корректно объявляет массив указателей на int?|int *Arr[10]|int (*Arr)[10]|int &Arr[10]|int Arr[10*]|int *Arr[10]|1|
|16|Массивы|Что произойдет, если вы попытаетесь скомпилировать и выполнить следующий код: int Arr[3]; Arr[4] = 5 ?|Значение будет успешно присвоено|Код скомпилируется и выполнится без ошибок|Произойдет ошибка времени выполнения|Произойдет присвоение Arr[3] значения 5|Произойдет ошибка времени выполнения|3|
|17|Массивы|Массив-это непрерывный участок памяти, содержащий последовательность объектов _________, обозначаемый одним именем.|одного типа|разных типов|числовых типов|символьных типов|одного типа|1|
|18|Массивы|Для обработки целочисленного массива в качестве аргументов функции необходимо передать|только адрес массива|только размер массива|адрес и размер массива|обязательно передать адрес, опционально размер массива|адрес и размер массива|3|
|19|Массивы|Для обработки строкового массива в качестве аргументов функции необходимо передать|только адрес массива|только размер массива|адрес и размер массива|обязательно передать адрес, опционально размер массива|обязательно передать адрес, опционально размер массива|4|
|20|Массивы|Каждый элемент массива характеризуется тремя величинами. Укажите лишнюю:|адрес элемента|тип данных элемента|индекс элемента|значение элемента|тип данных элемента|2|
|21|Строки|Для хранения строк используются массивы типа|char|int|string|float|char|1|
|22|Строки|Сколько байт данных хранит в себе тип char?|4|2|1|3|1|3|
|23|Строки|Какой терминальный символ хранит последний элемент строки?|\|\n|\0|0|\0|3|
|24|Строки|При использовании классификатора %s строка выводится|полностью|до первого терминального символа|до первой русской буквы|на ширину окна консоли|до первого терминального символа|2|
|25|Строки|Для ввода строк используется функция|gets()|puts()|read()|readstr()|gets()|1|
|26|Строки|Что возвращает функция gets()|массив символов|указатель на массив символов|размер массива|True, если массив заполнен. Иначе-False|указатель на массив символов|2|
|27|Строки|При использовании функции strcat(s1,s2),где s1,s2- массивы символов, результат хранится в|s1|s2|новом массиве символов s3|обоих массивах s1 и s2|s1|1|
|28|Строки|О какой функции идет речь: “считывает поток символов со стандартного устройства ввода в строку до тех пор, пока не будет нажата клавиша ENTER”|getchar()|isspace()|toupper()|gets()|gets()|4|
|29|Строки|Какая из приведенных ниже функций не подойдет для сравнения строк?|strcmp(s1,s2)|stricmp(s1,s2)|strcat(s1,s2)|strncmp(s1,s2,n)|strcat(s1,s2)|3|
|30|Строки|Какая из приведенных функций не возвращает значение типа bool?|isspace(c)|islower(c)|isalnum(c)|toupper(c)|toupper(c)|4|
|31|Рекурсия|Какая функция не может вызывать саму себя?|все могут|никакая не может|main()|все могут, если очень постараться|main()|3|
|32|Рекурсия|Как называется частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции?|хвостовая|конечная|бесконечная|кольцевая|хвостовая|1|
|33|Рекурсия|Что такое "глубина рекурсии"?|Количество вложенных вызовов рекурсивной функции.|Сложность базового случая.|Максимальный размер стека.|Это количество параметров, передаваемых в рекурсивную функцию.|Количество вложенных вызовов рекурсивной функции.|1|
|34|Рекурсия|Рекурсивный спуск это …|это метод поиска в дереве.|это алгоритм, используемый для сортировки данных.|это термин, обозначающий метод решения задачи путем последовательного рассмотрения подзадач с последующим объединением результатов.|это техника программирования, при которой функция вызывает саму себя с уменьшением размера входных данных до базового случая.|это техника программирования, при которой функция вызывает саму себя с уменьшением размера входных данных до базового случая.|4|
|35|Рекурсия|Условие при выполнении которого рекурсия заканчивается и функция больше не вызывает саму себя это …|Обычный случай|Базовый случай|Штатная ситуация|Условие выхода|Базовый случай|2|
|36|Рекурсия|В чем заключается опасность использования рекурсии?|При нехватке памяти может удалить важные данные|Может укусить|Может произойти переполнение стека|Использование рекурсии безопасно|Может произойти переполнение стека|3|
|37|Рекурсия|Завершение работы рекурсивных подпрограмм, вплоть до самой первой, инициировавшей рекурсивные вызовы, называется …|Рекурсивный подъем|Рекурсивный переворот|Рекурсивный спуск|Базовый случай|Рекурсивный подъем|1|
|38|Рекурсия|Что из этого НЕ является достоинством рекурсивных алгоритмов?|Есть алгоритмы, которые описываются рекурсией гораздо проще.|Часто код с рекурсией короче и проще, чем код цикла.|Иногда код рекурсии можно упаковать в несколько строк.|При каждом вызове рекурсивная функция добавляется в специальный стек.|При каждом вызове рекурсивная функция добавляется в специальный стек.|4|
|39|Рекурсия|Какая из задач решается только рекурсивно?|Обход дерева|Поиск факториала|Синтаксический разбор арифметических выражений|Ряд фибоначчи|Синтаксический разбор арифметических выражений|3|
|40|Рекурсия|Что произойдет при отсутствии условия выхода из рекурсивной функции?|Будет выведена ошибка "Stack Overflow".|Программа продолжит выполнение в бесконечном цикле.|Рекурсивные вызовы будут продолжаться бесконечно.|Программа завершится с ошибкой "Out of Memory".|Будет выведена ошибка "Stack Overflow".|1|
|41|Структуры|Как объявить структуру в C/C++|type myStruct {}|class myStruct {};|struct myStruct {};|int myStruct {};|struct myStruct {};|3|
|42|Структуры|Может ли структура содержать вложенные структуры?|Нет, это невозможно.|Да, структура может содержать вложенные структуры.|Только если они имеют одинаковые имена.|Только если вложенные структуры являются классами.|Да, структура может содержать вложенные структуры.|2|
|43|Структуры|Какова основная цель использования структур?|Для создания иерархии наследования.|Для организации и хранения связанных данных в одной единице.|Для реализации алгоритмов сортировки.|Для описания виртуальных функций.|Для организации и хранения связанных данных в одной единице.|2|
|44|Структуры|Какая структура данных наилучшим образом подходит для реализации алгоритма LIFO?|Дерево|Очередь|Стек|Куча|Стек|3|
|45|Структуры|Какая структура данных наилучшим образом подходит для реализации алгоритма FIFO?|Дерево|Очередь|Стек|Куча|Очередь|2|
|46|Структуры|Какая структура данных используется для хранения уникальных элементов без повторений?|Стек|Очередь|Множество|Список|Множество|3|
|47|Структуры|Какая операция выполняется наиболее медленно для связного списка?|Вставка в начало списка|Удаление из конца списка|Вставка в конец списка|Удаление элемента из середины списка|Удаление элемента из середины списка|4|
|48|Структуры|Какая операция выполняется наиболее медленно для связного списка?|Узел|Нить|Кирпич|Список|Узел|1|
|49|Структуры|Что из перечисленного не является структурой данных?|Стек|Массив|Цикл|Дерево|Цикл|3|
|50|Структуры|Что обязательно должен содержать в себе двусвязный список?|Значение и указатель на следующий элемент|Значение и указатели на следующий и предыдущий элементы|Значение|Он свободен и никому не должен|Значение и указатели на следующий и предыдущий элементы|2|
|51|Файлы|Какой из следующих режимов открытия файла позволяет только чтение данных из файла, но не позволяет запись?|ios::in|ios::out|ios::binary|ios::ate|ios::in|1|
|52|Файлы|Какой заголовочный файл нужно подключить для работы с файлами в C++?|iostream|fstream|filework|stdlib.h|fstream|2|
|53|Файлы|Какой метод используется для закрытия файла в C++?|file.close()|file.shutdown()|file.end()|file.terminate()|file.close()|1|
|54|Файлы|Какой заголовочный файл необходимо подключить для работы с файлами в языке C?|stdio.h|stdlib.h|filework|file.h|stdio.h|1|
|55|Файлы|Какой режим открытия файла позволяет осуществлять запись?|ios::in|ios::out|ios::app|ios::write|ios::out|2|
|56|Файлы|Как проверить, успешно ли произошло открытие файла для записи в C++?|Проверить, открыт ли файл с помощью file.is_open()|Использовать file.good() после открытия файла|Проверить, не равен ли file.fail() 1 после открытия файла|Проверить, не равен ли file.bad() 1 после открытия файла|Проверить, открыт ли файл с помощью file.is_open()|1|
|57|Файлы|Какой метод используется для проверки достижения конца файла в C++?|file.end_of_file()|file.eof()|file.is_eof()|file.is_end_of_file()|file.eof()|2|
|58|Файлы|Какая функция производит закрытия файла в языке C?|zakrit()|fclose()|fp.close()|close()|fclose()|2|
|59|Файлы|Что из нижеперечисленного успешно создаст и откроет файл для чтения в языке C?|FILE *fp = fopen("file.txt", "r")|FILE *fp = open("file.txt", "read");|FILE *fp = open_file("file.txt", "read");|FILE *fp = open("file.txt");|FILE *fp = fopen("file.txt", "r");|1|
|60|Файлы|Как перейти к началу файла для чтения/записи в C++?|file.seekg(0)|file.seekp(0)|file.seekg(0, ios::beg)|file.seekp(0, ios::beg)|file.seekg(0, ios::beg)|3|
|61|Адреса и указатели|Что такое указатель в языке C/C++?|Переменная, хранящая значение|Переменная, хранящая адрес другой переменной|Специальный тип данных для работы с файлами|Функция для вывода данных на экран|Переменная, хранящая адрес другой переменной|2|
|62|Адреса и указатели|Какая операция позволяет получить адрес переменной в C/C++?|*|&|%|->|&|2|
|63|Адреса и указатели|Как объявить указатель на функцию с одним целочисленным аргументом в C/C++?|int *func(int arg);|int (*func)(int);|int func(int *arg);|int func(*arg);|int (*func)(int);|2|
|64|Адреса и указатели|Что такое указатель на указатель (double pointer) в C/C++?|Указатель, хранящий адрес другого указателя|Указатель, который может хранить двойное значение|Указатель на двойной тип данных|Указатель, используемый для доступа к вложенным структурам данных|Указатель, хранящий адрес другого указателя|1|
|65|Адреса и указатели|Как удалить указатель?|Сборщик мусора самостоятельно удалит ненужные указатели|Приравнять указатель к nullptr|Использовать функцию delete ptr|Нельзя удалить указатель|Использовать функцию delete ptr|3|
|66|Адреса и указатели|Как создать указатель на переменную?|int* ptr = x|int* ptr = &x|int* ptr = *x|int* ptr = new int(x)|int* ptr = &x|2|
|67|Адреса и указатели|Что такое константный указатель?|Указатель, который не может быть изменен|Указатель, который указывает на константу и не может изменять ее значение|Указатель, который указывает на переменную и не может изменять ее значение|Указатель, который всегда указывает на одну и ту же область памяти|Указатель, который указывает на константу и не может изменять ее значение|2|
|68|Адреса и указатели|Как изменить значение переменной, на которую указывает указатель?|Изменить значение переменной по указателю с помощью оператора *|Изменить значение переменной по указателю с помощью оператора &|Присвоить новое значение указателю|Нельзя изменить значение переменной через указатель|Изменить значение переменной по указателю с помощью оператора *|1|
|69|Адреса и указатели|Как объявить ссылку на переменную int?|int *ref = &var|int ref = &var|int &ref = var|int ref = &(*var)|int &ref = var|3|
|70|Адреса и указатели|Как обозначить указатель нулевым?|ptr = 0|ptr = НОЛЬ|ptr = nullptr|Указатель должен ссылаться на что-либо|ptr = nullptr|3|
|71|Динамическая память|Чем отличается статическая память от динамической?|Статическая память распределяется динамически во время выполнения программы, в то время как динамическая память определяется статически на этапе компиляции|Статическая память хранится в ПЗУ, тогда как динамическая память хранится в ОЗУ|Статическая память обычно используется для хранения временных данных, в то время как динамическая память используется для постоянного хранения информации|Статическая память выделяется на этапе компиляции и остается существовать на протяжении всего времени работы программы, в то время как динамическая память выделяется и освобождается во время выполнения программы|Статическая память выделяется на этапе компиляции и остается существовать на протяжении всего времени работы программы, в то время как динамическая память выделяется и освобождается во время выполнения программы|4|
|72|Динамическая память|Как выделить память для переменной типа int?|new(“выделяемая память”)|alloc(“выделяемая память”)|malloc(“выделяемая память”)|calloc[“выделяемая память”]|malloc(“выделяемая память”)|3|
|73|Динамическая память|Как освободить выделенную динамическую память?|free(ptr)|delete(ptr)|destroy(ptr)|mclear(ptr)|free(ptr)|1|
|74|Динамическая память|Как изменить размер выделенной динамической памяти?|resize()|realloc()|alloc()|mresize()|realloc()|2|
|75|Динамическая память|Как не допустить утечки памяти при работе с динамической памятью?|Использовать оператор new вместо malloc(), так как последний устарел|Очищать все значения, хранящиеся в выделенной памяти|Использовать функцию alloc() для освобождения ненужной динамической памяти|Всегда очищать всю выделенную память|Всегда очищать всю выделенную память|4|
|76|Динамическая память|Чем отличается динамическая память объявленная через оператор new от malloc()?|new возвращает указатель на объект, а malloc() - на блок памяти|new можно использовать только для объектов классов, а malloc() - для любых типов данных|new автоматически вызывает конструкторы объектов, а malloc() - нет|new использует память более рационально по сравнению с malloc()|new возвращает указатель на объект, а malloc() - на блок памяти|1|
|77|Динамическая память|Как объявить динамический массив с помощью оператора malloc()?|(“тип данных”*)malloc(size)|malloc(“тип данных” * size)|malloc(size)|malloc(sizeof(“тип данных”)*size)|malloc(sizeof(“тип данных”)*size)|4|
|78|Динамическая память|Что возвращает функция malloc() в C/C++?|Указатель на новый объект|Указатель на новый массив|Динамическую переменную/массив|Указатель на выделенную область памяти|Указатель на выделенную область памяти|4|
|79|Динамическая память|Какой тип данных возвращает функция malloc()?|auto|void*|auto*|int|void*|2|
|80|Динамическая память|Что будет, если освободить память второй раз?|Поведение программы будет неопределенным|Появится утечка памяти|Будет возвращена ошибка компиляции|Программа аварийно завершится|Поведение программы будет неопределенным|1|
